#lang racket

; 1.1.7
; guess = 推定値
; x = 平方根を求めたい値
(define  (square x)
  (* x x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
    guess
    (sqrt-iter (improve guess x) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (sqrt x)
  (sqrt-iter 1.0 x))

; 平方根の計算で使ったgood-enough?テストは,
; 非常に小さい数の平方根をとる時には効果的ではない
; また, 実際の計算機では, 算術演算は殆んどの場合,
; 限られた精度で実行される.
; それでわれわれのテストは非常に大きい数にも不適切である.
; 小さい数, 大きい数の場合, どのようにテストが失敗するかの例を使ってこのことを説明せよ.
; good-enough?を実装するもう一つの戦略は,
; ある繰返しから次へのguessの変化に注目し,
; 変化が予測値に比べ非常に小さくなった時に止めるのである.
; こういう終了テストを使う平方根手続きを設計せよ.
; これは小さい数, 大きい数に対してうまく働くか.

; 非常に小さい数の場合、予測値と被開平数に比べて、現在使用している許容値が大きすぎるので、
; 割合的に差が大きい場合でもtrueを返してしまう。
;; 例えば
;; x = 0.00000001
;; の場合の平方根は0.0001になります。
;; 次にxの100倍の数値の0.000001の平方根は0.001になります。
;; 被開平数が100倍違うけれど、good-enough?ではtrueを返してしまい、
;; 求めていたような答えにならない。

; 非常に大きい数の場合、
; 現在使用している許容値の桁は既に丸められてしまっている可能性があり、
; 正常な比較ができない。

; x = 9999999999999999
; sqrt = 100000000

; (good-enough? 100000000 9999999999999999)
; (square 100000000)
; (square 100000001)
; (square 100000002)

; 9999999999999999
; 10000000000000000
; 22222222222222222
; 149071198.499985979015256
; 33333333333333333
; 182574185.835055370239452
(sqrt 9999999999999999)
;(sqrt 22222222222222222)
(sqrt 9999999999999)
